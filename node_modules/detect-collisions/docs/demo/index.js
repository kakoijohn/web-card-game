/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demo/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demo/examples/stress.js":
/*!*********************************!*\
  !*** ./demo/examples/stress.js ***!
  \*********************************/
/*! exports provided: Stress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Stress\", function() { return Stress; });\nconst { Collisions } = __webpack_require__(/*! ../../source */ \"./source/index.js\")\n\nconst result = Collisions.createResult()\nconst width = document.body.offsetWidth\nconst height = document.body.offsetHeight\nconst count = 500\nconst speed = 1\nconst size = 5\n\nlet frame = 0\nlet fps_total = 0\n\nclass Stress {\n    constructor() {\n        this.element = document.createElement('div')\n        this.canvas = document.createElement('canvas')\n        this.context = this.canvas.getContext('2d')\n        this.collisions = new Collisions()\n        this.bodies = []\n        this.polygons = 0\n        this.circles = 0\n\n        this.canvas.width = width\n        this.canvas.height = height\n        this.context.font = '24px Arial'\n\n        // World bounds\n        this.collisions.createPolygon(0, 0, [\n            [0, 0],\n            [width, 0]\n        ])\n        this.collisions.createPolygon(0, 0, [\n            [width, 0],\n            [width, height]\n        ])\n        this.collisions.createPolygon(0, 0, [\n            [width, height],\n            [0, height]\n        ])\n        this.collisions.createPolygon(0, 0, [\n            [0, height],\n            [0, 0]\n        ])\n\n        for (let i = 0; i < count; ++i) {\n            this.createShape(!random(0, 49))\n        }\n\n        this.element.innerHTML = `\n      <div><b>Total:</b> ${count}</div>\n      <div><b>Polygons:</b> ${this.polygons}</div>\n      <div><b>Circles:</b> ${this.circles}</div>\n      <div><label><input id=\"bvh\" type=\"checkbox\"> Show Bounding Volume Hierarchy</label></div>\n    `\n\n        this.bvh_checkbox = this.element.querySelector('#bvh')\n        this.element.appendChild(this.canvas)\n\n        const self = this\n\n        let time = performance.now()\n\n        this.frame = requestAnimationFrame(function frame() {\n            const current_time = performance.now()\n\n            self.update(1000 / (current_time - time))\n            self.frame = requestAnimationFrame(frame)\n\n            time = current_time\n        })\n    }\n\n    update(fps) {\n        this.collisions.update()\n\n        ++frame\n        fps_total += fps\n\n        const average_fps = Math.round(fps_total / frame)\n\n        if (frame > 100) {\n            frame = 1\n            fps_total = average_fps\n        }\n\n        for (let i = 0; i < this.bodies.length; ++i) {\n            const body = this.bodies[i]\n\n            body.x += body.direction_x * speed\n            body.y += body.direction_y * speed\n\n            const potentials = body.potentials()\n\n            for (const body2 of potentials) {\n                if (body.collides(body2, result)) {\n                    body.x -= result.overlap * result.overlap_x\n                    body.y -= result.overlap * result.overlap_y\n\n                    let dot = body.direction_x * result.overlap_y + body.direction_y * -result.overlap_x\n\n                    body.direction_x = 2 * dot * result.overlap_y - body.direction_x\n                    body.direction_y = 2 * dot * -result.overlap_x - body.direction_y\n\n                    dot = body2.direction_x * result.overlap_y + body2.direction_y * -result.overlap_x\n\n                    body2.direction_x = 2 * dot * result.overlap_y - body2.direction_x\n                    body2.direction_y = 2 * dot * -result.overlap_x - body2.direction_y\n                }\n            }\n        }\n\n        // Clear the canvas\n        this.context.fillStyle = '#000000'\n        this.context.fillRect(0, 0, width, height)\n\n        // Render the bodies\n        this.context.strokeStyle = '#FFFFFF'\n        this.context.beginPath()\n        this.collisions.draw(this.context)\n        this.context.stroke()\n\n        // Render the BVH\n        if (this.bvh_checkbox.checked) {\n            this.context.strokeStyle = '#00FF00'\n            this.context.beginPath()\n            this.collisions.drawBVH(this.context)\n            this.context.stroke()\n        }\n\n        // Render the FPS\n        this.context.fillStyle = '#FFCC00'\n        this.context.fillText(average_fps, 10, 30)\n    }\n\n    createShape(large) {\n        const min_size = size * 0.75 * (large ? 3 : 1)\n        const max_size = size * 1.25 * (large ? 5 : 1)\n        const x = random(0, width)\n        const y = random(0, height)\n        const direction = random(0, 360) * Math.PI / 180\n\n        let body\n\n        if (random(0, 2)) {\n            body = this.collisions.createCircle(x, y, random(min_size, max_size))\n\n            ++this.circles\n        } else {\n            body = this.collisions.createPolygon(x, y, [\n                [-random(min_size, max_size), -random(min_size, max_size)],\n                [random(min_size, max_size), -random(min_size, max_size)],\n                [random(min_size, max_size), random(min_size, max_size)],\n                [-random(min_size, max_size), random(3, size)]\n            ], random(0, 360) * Math.PI / 180)\n\n            ++this.polygons\n        }\n\n        body.direction_x = Math.cos(direction)\n        body.direction_y = Math.sin(direction)\n\n        this.bodies.push(body)\n    }\n}\n\nfunction random(min, max) {\n    return Math.floor(Math.random() * max) + min\n}\n\n//# sourceURL=webpack:///./demo/examples/stress.js?");

/***/ }),

/***/ "./demo/examples/tank.js":
/*!*******************************!*\
  !*** ./demo/examples/tank.js ***!
  \*******************************/
/*! exports provided: Tank */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tank\", function() { return Tank; });\nconst { Collisions } = __webpack_require__(/*! ../../source */ \"./source/index.js\");\n\nconst result = Collisions.createResult();\n\nclass Tank {\n    constructor() {\n        const width = document.body.offsetWidth;\n        const height = document.body.offsetHeight;\n        const collisions = new Collisions();\n\n        this.element = document.createElement(\"div\");\n        this.canvas = document.createElement(\"canvas\");\n        this.context = this.canvas.getContext(\"2d\");\n        this.collisions = collisions;\n        this.bodies = [];\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.player = null;\n\n        this.up = false;\n        this.down = false;\n        this.left = false;\n        this.right = false;\n\n        this.element.innerHTML = `\n      <div><b>W, S</b> - Accelerate/Decelerate</div>\n      <div><b>A, D</b> - Turn</div>\n      <div><label><input id=\"bvh\" type=\"checkbox\"> Show Bounding Volume Hierarchy</label></div>\n    `;\n\n        const updateKeys = e => {\n            const keydown = e.type === \"keydown\";\n            const key = e.key.toLowerCase();\n\n            key === \"w\" && (this.up = keydown);\n            key === \"s\" && (this.down = keydown);\n            key === \"a\" && (this.left = keydown);\n            key === \"d\" && (this.right = keydown);\n        };\n\n        document.addEventListener(\"keydown\", updateKeys);\n        document.addEventListener(\"keyup\", updateKeys);\n\n        this.bvh_checkbox = this.element.querySelector(\"#bvh\");\n        this.element.appendChild(this.canvas);\n\n        this.createPlayer(width / 2, height / 2);\n        this.createMap(width, height);\n\n        const frame = () => {\n            this.update();\n            requestAnimationFrame(frame);\n        };\n\n        frame();\n    }\n\n    update() {\n        this.handleInput();\n        this.processGameLogic();\n        this.handleCollisions();\n        this.render();\n    }\n\n    handleInput() {\n        this.up && (this.player.velocity += 0.1);\n        this.down && (this.player.velocity -= 0.1);\n        this.left && (this.player.angle -= 0.04);\n        this.right && (this.player.angle += 0.04);\n    }\n\n    processGameLogic() {\n        const x = Math.cos(this.player.angle);\n        const y = Math.sin(this.player.angle);\n\n        if (this.player.velocity > 0) {\n            this.player.velocity -= 0.05;\n\n            if (this.player.velocity > 3) {\n                this.player.velocity = 3;\n            }\n        } else if (this.player.velocity < 0) {\n            this.player.velocity += 0.05;\n\n            if (this.player.velocity < -2) {\n                this.player.velocity = -2;\n            }\n        }\n\n        if (!Math.round(this.player.velocity * 100)) {\n            this.player.velocity = 0;\n        }\n\n        if (this.player.velocity) {\n            this.player.x += x * this.player.velocity;\n            this.player.y += y * this.player.velocity;\n        }\n    }\n\n    handleCollisions() {\n        this.collisions.update();\n\n        const potentials = this.player.potentials();\n\n        // Negate any collisions\n        for (const body of potentials) {\n            if (this.player.collides(body, result)) {\n                this.player.x -= result.overlap * result.overlap_x;\n                this.player.y -= result.overlap * result.overlap_y;\n\n                this.player.velocity *= 0.9;\n            }\n        }\n    }\n\n    render() {\n        this.context.fillStyle = \"#000000\";\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        this.context.strokeStyle = \"#FFFFFF\";\n        this.context.beginPath();\n        this.collisions.draw(this.context);\n        this.context.stroke();\n\n        if (this.bvh_checkbox.checked) {\n            this.context.strokeStyle = \"#00FF00\";\n            this.context.beginPath();\n            this.collisions.drawBVH(this.context);\n            this.context.stroke();\n        }\n    }\n\n    createPlayer(x, y, size = 15) {\n        this.player = this.collisions.createPolygon(\n            x,\n            y, [\n                [-size * 2, -size],\n                [size * 2, -size],\n                [size * 2, size],\n                [-size * 2, size]\n            ],\n            0.2\n        );\n\n        this.player.velocity = 0;\n    }\n\n    scaleX(x) {\n        return (x / 800) * this.canvas.width;\n    }\n\n    scaleY(y) {\n        return (y / 600) * this.canvas.height;\n    }\n\n    createCircle(x, y, radius) {\n        this.collisions.createCircle(this.scaleX(x), this.scaleY(y), radius);\n    }\n\n    createPolygon(x, y, points, angle) {\n        const scaledPoints = points.map(([pointX, pointY]) => [\n            this.scaleX(pointX),\n            this.scaleY(pointY)\n        ]);\n\n        this.collisions.createPolygon(\n            this.scaleX(x),\n            this.scaleY(y),\n            scaledPoints,\n            angle\n        );\n    }\n\n    createMap(width, height) {\n        // World bounds\n        this.createPolygon(0, 0, [\n            [0, 0],\n            [width, 0]\n        ]);\n        this.createPolygon(0, 0, [\n            [width, 0],\n            [width, height]\n        ]);\n        this.createPolygon(0, 0, [\n            [width, height],\n            [0, height]\n        ]);\n        this.createPolygon(0, 0, [\n            [0, height],\n            [0, 0]\n        ]);\n\n        // Factory\n        this.createPolygon(\n            100,\n            100, [\n                [-50, -50],\n                [50, -50],\n                [50, 50],\n                [-50, 50]\n            ],\n            0.4\n        );\n        this.createPolygon(\n            190,\n            105, [\n                [-20, -20],\n                [20, -20],\n                [20, 20],\n                [-20, 20]\n            ],\n            0.4\n        );\n        this.createCircle(170, 140, 8);\n        this.createCircle(185, 155, 8);\n        this.createCircle(165, 165, 8);\n        this.createCircle(145, 165, 8);\n\n        // Airstrip\n        this.createPolygon(\n            230,\n            50, [\n                [-150, -30],\n                [150, -30],\n                [150, 30],\n                [-150, 30]\n            ],\n            0.4\n        );\n\n        // HQ\n        this.createPolygon(\n            100,\n            500, [\n                [-40, -50],\n                [40, -50],\n                [50, 50],\n                [-50, 50]\n            ],\n            0.2\n        );\n        this.createCircle(180, 490, 20);\n        this.createCircle(175, 540, 20);\n\n        // Barracks\n        this.createPolygon(\n            400,\n            500, [\n                [-60, -20],\n                [60, -20],\n                [60, 20],\n                [-60, 20]\n            ],\n            1.7\n        );\n        this.createPolygon(\n            350,\n            494, [\n                [-60, -20],\n                [60, -20],\n                [60, 20],\n                [-60, 20]\n            ],\n            1.7\n        );\n\n        // Mountains\n        this.createPolygon(750, 0, [\n            [0, 0],\n            [-20, 100]\n        ]);\n        this.createPolygon(750, 0, [\n            [-20, 100],\n            [30, 250]\n        ]);\n        this.createPolygon(750, 0, [\n            [30, 250],\n            [20, 300]\n        ]);\n        this.createPolygon(750, 0, [\n            [20, 300],\n            [-50, 320]\n        ]);\n        this.createPolygon(750, 0, [\n            [-50, 320],\n            [-90, 500]\n        ]);\n        this.createPolygon(750, 0, [\n            [-90, 500],\n            [-200, 600]\n        ]);\n\n        // Lake\n        this.createPolygon(550, 100, [\n            [-60, -20],\n            [-20, -40],\n            [30, -30],\n            [60, 20],\n            [40, 70],\n            [10, 100],\n            [-30, 110],\n            [-80, 90],\n            [-110, 50],\n            [-100, 20]\n        ]);\n    }\n}\n\n//# sourceURL=webpack:///./demo/examples/tank.js?");

/***/ }),

/***/ "./demo/index.js":
/*!***********************!*\
  !*** ./demo/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("if (window.location.search.indexOf(\"?stress\") !== -1) {\n    const { Stress } = __webpack_require__(/*! ./examples/stress */ \"./demo/examples/stress.js\");\n\n    document.body.appendChild(new Stress().element);\n} else {\n    const { Tank } = __webpack_require__(/*! ./examples/tank */ \"./demo/examples/tank.js\");\n\n    document.body.appendChild(new Tank().element);\n}\n\n//# sourceURL=webpack:///./demo/index.js?");

/***/ }),

/***/ "./source/index.js":
/*!*************************!*\
  !*** ./source/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { BVH, Circle, Polygon, Point, Result, SAT } = __webpack_require__(/*! ./modules */ \"./source/modules/index.js\")\n\n/**\n * A collision system used to track bodies in order to improve collision detection performance\n * @class\n */\nclass Collisions {\n  /**\n   * @constructor\n   */\n  constructor () {\n    /** @private */\n    this._bvh = new BVH()\n  }\n\n  /**\n   * Creates a {@link Circle} and inserts it into the collision system\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [radius = 0] The radius\n   * @param {Number} [scale = 1] The scale\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   * @returns {Circle}\n   */\n  createCircle (x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n    const body = new Circle(x, y, radius, scale, padding)\n\n    this._bvh.insert(body)\n\n    return body\n  }\n\n  /**\n   * Creates a {@link Polygon} and inserts it into the collision system\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n   * @param {Number} [angle = 0] The starting rotation in radians\n   * @param {Number} [scale_x = 1] The starting scale along the X axis\n   * @param {Number} [scale_y = 1] The starting scale long the Y axis\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   * @returns {Polygon}\n   */\n  createPolygon (x = 0, y = 0, points = [[0, 0]], angle = 0, scale_x = 1, scale_y = 1, padding = 0) {\n    const body = new Polygon(x, y, points, angle, scale_x, scale_y, padding)\n\n    this._bvh.insert(body)\n\n    return body\n  }\n\n  /**\n   * Creates a {@link Point} and inserts it into the collision system\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   * @returns {Point}\n   */\n  createPoint (x = 0, y = 0, padding = 0) {\n    const body = new Point(x, y, padding)\n\n    this._bvh.insert(body)\n\n    return body\n  }\n\n  /**\n   * Creates a {@link Result} used to collect the detailed results of a collision test\n   */\n  createResult () {\n    return new Result()\n  }\n\n  /**\n   * Creates a Result used to collect the detailed results of a collision test\n   */\n  static createResult () {\n    return new Result()\n  }\n\n  /**\n   * Inserts bodies into the collision system\n   * @param {...Circle|...Polygon|...Point} bodies\n   */\n  insert (...bodies) {\n    for (const body of bodies) {\n      this._bvh.insert(body, false)\n    }\n\n    return this\n  }\n\n  /**\n   * Removes bodies = require(the collision system\n   * @param {...Circle|...Polygon|...Point} bodies\n   */\n  remove (...bodies) {\n    for (const body of bodies) {\n      this._bvh.remove(body, false)\n    }\n\n    return this\n  }\n\n  /**\n   * Updates the collision system. This should be called before any collisions are tested.\n   */\n  update () {\n    this._bvh.update()\n\n    return this\n  }\n\n  /**\n   * Draws the bodies within the system to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  draw (context) {\n    return this._bvh.draw(context)\n  }\n\n  /**\n   * Draws the system's BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  drawBVH (context) {\n    return this._bvh.drawBVH(context)\n  }\n\n  /**\n   * Returns a list of potential collisions for a body\n   * @param {Circle|Polygon|Point} body The body to test for potential collisions against\n   * @returns {Array<Body>}\n   */\n  potentials (body) {\n    return this._bvh.potentials(body)\n  }\n\n  /**\n   * Determines if two bodies are colliding\n   * @param {Circle|Polygon|Point} target The target body to test against\n   * @param {Result} [result = null] A Result object on which to store information about the collision\n   * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n   * @returns {Boolean}\n   */\n  collides (source, target, result = null, aabb = true) {\n    return SAT(source, target, result, aabb)\n  }\n};\n\nmodule.exports = {\n  Collisions, BVH, Circle, Polygon, Point, Result, SAT\n}\n\n\n//# sourceURL=webpack:///./source/index.js?");

/***/ }),

/***/ "./source/modules/BVH.js":
/*!*******************************!*\
  !*** ./source/modules/BVH.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const BVHBranch = __webpack_require__(/*! ./BVHBranch */ \"./source/modules/BVHBranch.js\")\n\n/**\n * A Bounding Volume Hierarchy (BVH) used to find potential collisions quickly\n * @class\n * @private\n */\nclass BVH {\n  /**\n   * @constructor\n   */\n  constructor () {\n    /** @private */\n    this._hierarchy = null\n\n    /** @private */\n    this._bodies = []\n\n    /** @private */\n    this._dirty_branches = []\n  }\n\n  /**\n   * Inserts a body into the BVH\n   * @param {Circle|Polygon|Point} body The body to insert\n   * @param {Boolean} [updating = false] Set to true if the body already exists in the BVH (used internally when updating the body's position)\n   */\n  insert (body, updating = false) {\n    if (!updating) {\n      const bvh = body._bvh\n\n      if (bvh && bvh !== this) {\n        throw new Error('Body belongs to another collision system')\n      }\n\n      body._bvh = this\n      this._bodies.push(body)\n    }\n\n    const polygon = body._polygon\n    const body_x = body.x\n    const body_y = body.y\n\n    if (polygon) {\n      if (\n        body._dirty_coords ||\n        body.x !== body._x ||\n        body.y !== body._y ||\n        body.angle !== body._angle ||\n        body.scale_x !== body._scale_x ||\n        body.scale_y !== body._scale_y\n      ) {\n        body._calculateCoords()\n      }\n    }\n\n    const padding = body._bvh_padding\n    const radius = polygon ? 0 : body.radius * body.scale\n    const body_min_x = (polygon ? body._min_x : body_x - radius) - padding\n    const body_min_y = (polygon ? body._min_y : body_y - radius) - padding\n    const body_max_x = (polygon ? body._max_x : body_x + radius) + padding\n    const body_max_y = (polygon ? body._max_y : body_y + radius) + padding\n\n    body._bvh_min_x = body_min_x\n    body._bvh_min_y = body_min_y\n    body._bvh_max_x = body_max_x\n    body._bvh_max_y = body_max_y\n\n    let current = this._hierarchy\n    let sort = 0\n\n    if (!current) {\n      this._hierarchy = body\n    } else {\n      while (true) {\n        // Branch\n        if (current._bvh_branch) {\n          const left = current._bvh_left\n          const left_min_y = left._bvh_min_y\n          const left_max_x = left._bvh_max_x\n          const left_max_y = left._bvh_max_y\n          const left_new_min_x = body_min_x < left._bvh_min_x ? body_min_x : left._bvh_min_x\n          const left_new_min_y = body_min_y < left_min_y ? body_min_y : left_min_y\n          const left_new_max_x = body_max_x > left_max_x ? body_max_x : left_max_x\n          const left_new_max_y = body_max_y > left_max_y ? body_max_y : left_max_y\n          const left_volume = (left_max_x - left._bvh_min_x) * (left_max_y - left_min_y)\n          const left_new_volume = (left_new_max_x - left_new_min_x) * (left_new_max_y - left_new_min_y)\n          const left_difference = left_new_volume - left_volume\n\n          const right = current._bvh_right\n          const right_min_x = right._bvh_min_x\n          const right_min_y = right._bvh_min_y\n          const right_max_x = right._bvh_max_x\n          const right_max_y = right._bvh_max_y\n          const right_new_min_x = body_min_x < right_min_x ? body_min_x : right_min_x\n          const right_new_min_y = body_min_y < right_min_y ? body_min_y : right_min_y\n          const right_new_max_x = body_max_x > right_max_x ? body_max_x : right_max_x\n          const right_new_max_y = body_max_y > right_max_y ? body_max_y : right_max_y\n          const right_volume = (right_max_x - right_min_x) * (right_max_y - right_min_y)\n          const right_new_volume = (right_new_max_x - right_new_min_x) * (right_new_max_y - right_new_min_y)\n          const right_difference = right_new_volume - right_volume\n\n          current._bvh_sort = sort++\n          current._bvh_min_x = left_new_min_x < right_new_min_x ? left_new_min_x : right_new_min_x\n          current._bvh_min_y = left_new_min_y < right_new_min_y ? left_new_min_y : right_new_min_y\n          current._bvh_max_x = left_new_max_x > right_new_max_x ? left_new_max_x : right_new_max_x\n          current._bvh_max_y = left_new_max_y > right_new_max_y ? left_new_max_y : right_new_max_y\n\n          current = left_difference <= right_difference ? left : right\n        } else {\n        // Leaf\n          const grandparent = current._bvh_parent\n          const parent_min_x = current._bvh_min_x\n          const parent_min_y = current._bvh_min_y\n          const parent_max_x = current._bvh_max_x\n          const parent_max_y = current._bvh_max_y\n          const new_parent = current._bvh_parent = body._bvh_parent = BVHBranch.getBranch()\n\n          new_parent._bvh_parent = grandparent\n          new_parent._bvh_left = current\n          new_parent._bvh_right = body\n          new_parent._bvh_sort = sort++\n          new_parent._bvh_min_x = body_min_x < parent_min_x ? body_min_x : parent_min_x\n          new_parent._bvh_min_y = body_min_y < parent_min_y ? body_min_y : parent_min_y\n          new_parent._bvh_max_x = body_max_x > parent_max_x ? body_max_x : parent_max_x\n          new_parent._bvh_max_y = body_max_y > parent_max_y ? body_max_y : parent_max_y\n\n          if (!grandparent) {\n            this._hierarchy = new_parent\n          } else if (grandparent._bvh_left === current) {\n            grandparent._bvh_left = new_parent\n          } else {\n            grandparent._bvh_right = new_parent\n          }\n\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes a body from the BVH\n   * @param {Circle|Polygon|Point} body The body to remove\n   * @param {Boolean} [updating = false] Set to true if this is a temporary removal (used internally when updating the body's position)\n   */\n  remove (body, updating = false) {\n    if (!updating) {\n      const bvh = body._bvh\n\n      if (bvh && bvh !== this) {\n        throw new Error('Body belongs to another collision system')\n      }\n\n      body._bvh = null\n      this._bodies.splice(this._bodies.indexOf(body), 1)\n    }\n\n    if (this._hierarchy === body) {\n      this._hierarchy = null\n\n      return\n    }\n\n    const parent = body._bvh_parent\n    const grandparent = parent._bvh_parent\n    const parent_left = parent._bvh_left\n    const sibling = parent_left === body ? parent._bvh_right : parent_left\n\n    sibling._bvh_parent = grandparent\n\n    if (sibling._bvh_branch) {\n      sibling._bvh_sort = parent._bvh_sort\n    }\n\n    if (grandparent) {\n      if (grandparent._bvh_left === parent) {\n        grandparent._bvh_left = sibling\n      } else {\n        grandparent._bvh_right = sibling\n      }\n\n      let branch = grandparent\n\n      while (branch) {\n        const left = branch._bvh_left\n        const left_min_x = left._bvh_min_x\n        const left_min_y = left._bvh_min_y\n        const left_max_x = left._bvh_max_x\n        const left_max_y = left._bvh_max_y\n\n        const right = branch._bvh_right\n        const right_min_x = right._bvh_min_x\n        const right_min_y = right._bvh_min_y\n        const right_max_x = right._bvh_max_x\n        const right_max_y = right._bvh_max_y\n\n        branch._bvh_min_x = left_min_x < right_min_x ? left_min_x : right_min_x\n        branch._bvh_min_y = left_min_y < right_min_y ? left_min_y : right_min_y\n        branch._bvh_max_x = left_max_x > right_max_x ? left_max_x : right_max_x\n        branch._bvh_max_y = left_max_y > right_max_y ? left_max_y : right_max_y\n\n        branch = branch._bvh_parent\n      }\n    } else {\n      this._hierarchy = sibling\n    }\n\n    BVHBranch.releaseBranch(parent)\n  }\n\n  /**\n   * Updates the BVH. Moved bodies are removed/inserted.\n   */\n  update () {\n    const bodies = this._bodies\n    const count = bodies.length\n\n    for (let i = 0; i < count; ++i) {\n      const body = bodies[i]\n\n      let update = false\n\n      if (!update && body.padding !== body._bvh_padding) {\n        body._bvh_padding = body.padding\n        update = true\n      }\n\n      if (!update) {\n        const polygon = body._polygon\n\n        if (polygon) {\n          if (\n            body._dirty_coords ||\n            body.x !== body._x ||\n            body.y !== body._y ||\n            body.angle !== body._angle ||\n            body.scale_x !== body._scale_x ||\n            body.scale_y !== body._scale_y\n          ) {\n            body._calculateCoords()\n          }\n        }\n\n        const x = body.x\n        const y = body.y\n        const radius = polygon ? 0 : body.radius * body.scale\n        const min_x = polygon ? body._min_x : x - radius\n        const min_y = polygon ? body._min_y : y - radius\n        const max_x = polygon ? body._max_x : x + radius\n        const max_y = polygon ? body._max_y : y + radius\n\n        update = min_x < body._bvh_min_x || min_y < body._bvh_min_y || max_x > body._bvh_max_x || max_y > body._bvh_max_y\n      }\n\n      if (update) {\n        this.remove(body, true)\n        this.insert(body, true)\n      }\n    }\n  }\n\n  /**\n   * Returns a list of potential collisions for a body\n   * @param {Circle|Polygon|Point} body The body to test\n   * @returns {Array<Body>}\n   */\n  potentials (body) {\n    const results = []\n    const min_x = body._bvh_min_x\n    const min_y = body._bvh_min_y\n    const max_x = body._bvh_max_x\n    const max_y = body._bvh_max_y\n\n    let current = this._hierarchy\n    let traverse_left = true\n\n    if (!current || !current._bvh_branch) {\n      return results\n    }\n\n    while (current) {\n      if (traverse_left) {\n        traverse_left = false\n\n        let left = current._bvh_branch ? current._bvh_left : null\n\n        while (\n          left &&\n          left._bvh_max_x >= min_x &&\n          left._bvh_max_y >= min_y &&\n          left._bvh_min_x <= max_x &&\n          left._bvh_min_y <= max_y\n        ) {\n          current = left\n          left = current._bvh_branch ? current._bvh_left : null\n        }\n      }\n\n      const branch = current._bvh_branch\n      const right = branch ? current._bvh_right : null\n\n      if (\n        right &&\n        right._bvh_max_x > min_x &&\n        right._bvh_max_y > min_y &&\n        right._bvh_min_x < max_x &&\n        right._bvh_min_y < max_y\n      ) {\n        current = right\n        traverse_left = true\n      } else {\n        if (!branch && current !== body) {\n          results.push(current)\n        }\n\n        let parent = current._bvh_parent\n\n        if (parent) {\n          while (parent && parent._bvh_right === current) {\n            current = parent\n            parent = current._bvh_parent\n          }\n\n          current = parent\n        } else {\n          break\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Draws the bodies within the BVH to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  draw (context) {\n    const bodies = this._bodies\n    const count = bodies.length\n\n    for (let i = 0; i < count; ++i) {\n      bodies[i].draw(context)\n    }\n  }\n\n  /**\n   * Draws the BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  drawBVH (context) {\n    let current = this._hierarchy\n    let traverse_left = true\n\n    while (current) {\n      if (traverse_left) {\n        traverse_left = false\n\n        let left = current._bvh_branch ? current._bvh_left : null\n\n        while (left) {\n          current = left\n          left = current._bvh_branch ? current._bvh_left : null\n        }\n      }\n\n      const branch = current._bvh_branch\n      const min_x = current._bvh_min_x\n      const min_y = current._bvh_min_y\n      const max_x = current._bvh_max_x\n      const max_y = current._bvh_max_y\n      const right = branch ? current._bvh_right : null\n\n      context.moveTo(min_x, min_y)\n      context.lineTo(max_x, min_y)\n      context.lineTo(max_x, max_y)\n      context.lineTo(min_x, max_y)\n      context.lineTo(min_x, min_y)\n\n      if (right) {\n        current = right\n        traverse_left = true\n      } else {\n        let parent = current._bvh_parent\n\n        if (parent) {\n          while (parent && parent._bvh_right === current) {\n            current = parent\n            parent = current._bvh_parent\n          }\n\n          current = parent\n        } else {\n          break\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = BVH\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/BVH.js?");

/***/ }),

/***/ "./source/modules/BVHBranch.js":
/*!*************************************!*\
  !*** ./source/modules/BVHBranch.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @private\n */\nconst branch_pool = []\n\n/**\n * A branch within a BVH\n * @class\n * @private\n */\nclass BVHBranch {\n  /**\n   * @constructor\n   */\n  constructor () {\n    /** @private */\n    this._bvh_parent = null\n\n    /** @private */\n    this._bvh_branch = true\n\n    /** @private */\n    this._bvh_left = null\n\n    /** @private */\n    this._bvh_right = null\n\n    /** @private */\n    this._bvh_sort = 0\n\n    /** @private */\n    this._bvh_min_x = 0\n\n    /** @private */\n    this._bvh_min_y = 0\n\n    /** @private */\n    this._bvh_max_x = 0\n\n    /** @private */\n    this._bvh_max_y = 0\n  }\n\n  /**\n   * Returns a branch from the branch pool or creates a new branch\n   * @returns {BVHBranch}\n   */\n  static getBranch () {\n    if (branch_pool.length) {\n      return branch_pool.pop()\n    }\n\n    return new BVHBranch()\n  }\n\n  /**\n   * Releases a branch back into the branch pool\n   * @param {BVHBranch} branch The branch to release\n   */\n  static releaseBranch (branch) {\n    branch_pool.push(branch)\n  }\n\n  /**\n   * Sorting callback used to sort branches by deepest first\n   * @param {BVHBranch} a The first branch\n   * @param {BVHBranch} b The second branch\n   * @returns {Number}\n   */\n  static sortBranches (a, b) {\n    return a.sort > b.sort ? -1 : 1\n  }\n};\n\nmodule.exports = BVHBranch\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/BVHBranch.js?");

/***/ }),

/***/ "./source/modules/Body.js":
/*!********************************!*\
  !*** ./source/modules/Body.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Result = __webpack_require__(/*! ./Result */ \"./source/modules/Result.js\")\nconst SAT = __webpack_require__(/*! ./SAT */ \"./source/modules/SAT.js\")\n\n/**\n * The base class for bodies used to detect collisions\n * @class\n * @protected\n */\nclass Body {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor (x = 0, y = 0, padding = 0) {\n    /**\n     * @desc The X coordinate of the body\n     * @type {Number}\n     */\n    this.x = x\n\n    /**\n     * @desc The Y coordinate of the body\n     * @type {Number}\n     */\n    this.y = y\n\n    /**\n     * @desc The amount to pad the bounding volume when testing for potential collisions\n     * @type {Number}\n     */\n    this.padding = padding\n\n    /** @private */\n    this._circle = false\n\n    /** @private */\n    this._polygon = false\n\n    /** @private */\n    this._point = false\n\n    /** @private */\n    this._bvh = null\n\n    /** @private */\n    this._bvh_parent = null\n\n    /** @private */\n    this._bvh_branch = false\n\n    /** @private */\n    this._bvh_padding = padding\n\n    /** @private */\n    this._bvh_min_x = 0\n\n    /** @private */\n    this._bvh_min_y = 0\n\n    /** @private */\n    this._bvh_max_x = 0\n\n    /** @private */\n    this._bvh_max_y = 0\n  }\n\n  /**\n   * Determines if the body is colliding with another body\n   * @param {Circle|Polygon|Point} target The target body to test against\n   * @param {Result} [result = null] A Result object on which to store information about the collision\n   * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n   * @returns {Boolean}\n   */\n  collides (target, result = null, aabb = true) {\n    return SAT(this, target, result, aabb)\n  }\n\n  /**\n   * Returns a list of potential collisions\n   * @returns {Array<Body>}\n   */\n  potentials () {\n    const bvh = this._bvh\n\n    if (bvh === null) {\n      throw new Error('Body does not belong to a collision system')\n    }\n\n    return bvh.potentials(this)\n  }\n\n  /**\n   * Removes the body from its current collision system\n   */\n  remove () {\n    const bvh = this._bvh\n\n    if (bvh) {\n      bvh.remove(this, false)\n    }\n  }\n\n  /**\n   * Creates a {@link Result} used to collect the detailed results of a collision test\n   */\n  createResult () {\n    return new Result()\n  }\n\n  /**\n   * Creates a Result used to collect the detailed results of a collision test\n   */\n  static createResult () {\n    return new Result()\n  }\n};\n\nmodule.exports = Body\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/Body.js?");

/***/ }),

/***/ "./source/modules/Circle.js":
/*!**********************************!*\
  !*** ./source/modules/Circle.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Body = __webpack_require__(/*! ./Body */ \"./source/modules/Body.js\")\n\n/**\n * A circle used to detect collisions\n * @class\n */\nclass Circle extends Body {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [radius = 0] The radius\n   * @param {Number} [scale = 1] The scale\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor (x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n    super(x, y, padding)\n\n    /**\n     * @type {Number}\n     */\n    this.radius = radius\n\n    /**\n     * @type {Number}\n     */\n    this.scale = scale\n  }\n\n  /**\n   * Draws the circle to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to add the arc to\n   */\n  draw (context) {\n    const x = this.x\n    const y = this.y\n    const radius = this.radius * this.scale\n\n    context.moveTo(x + radius, y)\n    context.arc(x, y, radius, 0, Math.PI * 2)\n  }\n};\n\nmodule.exports = Circle\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/Circle.js?");

/***/ }),

/***/ "./source/modules/Point.js":
/*!*********************************!*\
  !*** ./source/modules/Point.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Polygon = __webpack_require__(/*! ./Polygon */ \"./source/modules/Polygon.js\")\n\n/**\n * A point used to detect collisions\n * @class\n */\nclass Point extends Polygon {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor (x = 0, y = 0, padding = 0) {\n    super(x, y, [[0, 0]], 0, 1, 1, padding)\n\n    /** @private */\n    this._point = true\n  }\n};\n\nPoint.prototype.setPoints = undefined\n\nmodule.exports = Point\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/Point.js?");

/***/ }),

/***/ "./source/modules/Polygon.js":
/*!***********************************!*\
  !*** ./source/modules/Polygon.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Body = __webpack_require__(/*! ./Body */ \"./source/modules/Body.js\")\n\n/**\n * A polygon used to detect collisions\n * @class\n */\nclass Polygon extends Body {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n   * @param {Number} [angle = 0] The starting rotation in radians\n   * @param {Number} [scale_x = 1] The starting scale along the X axis\n   * @param {Number} [scale_y = 1] The starting scale long the Y axis\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor (x = 0, y = 0, points = [], angle = 0, scale_x = 1, scale_y = 1, padding = 0) {\n    super(x, y, padding)\n\n    /**\n     * @desc The angle of the body in radians\n     * @type {Number}\n     */\n    this.angle = angle\n\n    /**\n     * @desc The scale of the body along the X axis\n     * @type {Number}\n     */\n    this.scale_x = scale_x\n\n    /**\n     * @desc The scale of the body along the Y axis\n     * @type {Number}\n     */\n    this.scale_y = scale_y\n\n    /** @private */\n    this._polygon = true\n\n    /** @private */\n    this._x = x\n\n    /** @private */\n    this._y = y\n\n    /** @private */\n    this._angle = angle\n\n    /** @private */\n    this._scale_x = scale_x\n\n    /** @private */\n    this._scale_y = scale_y\n\n    /** @private */\n    this._min_x = 0\n\n    /** @private */\n    this._min_y = 0\n\n    /** @private */\n    this._max_x = 0\n\n    /** @private */\n    this._max_y = 0\n\n    /** @private */\n    this._points = null\n\n    /** @private */\n    this._coords = null\n\n    /** @private */\n    this._edges = null\n\n    /** @private */\n    this._normals = null\n\n    /** @private */\n    this._dirty_coords = true\n\n    /** @private */\n    this._dirty_normals = true\n\n    Polygon.prototype.setPoints.call(this, points)\n  }\n\n  /**\n   * Draws the polygon to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to add the shape to\n   */\n  draw (context) {\n    if (\n      this._dirty_coords ||\n      this.x !== this._x ||\n      this.y !== this._y ||\n      this.angle !== this._angle ||\n      this.scale_x !== this._scale_x ||\n      this.scale_y !== this._scale_y\n    ) {\n      this._calculateCoords()\n    }\n\n    const coords = this._coords\n\n    if (coords.length === 2) {\n      context.moveTo(coords[0], coords[1])\n      context.arc(coords[0], coords[1], 1, 0, Math.PI * 2)\n    } else {\n      context.moveTo(coords[0], coords[1])\n\n      for (let i = 2; i < coords.length; i += 2) {\n        context.lineTo(coords[i], coords[i + 1])\n      }\n\n      if (coords.length > 4) {\n        context.lineTo(coords[0], coords[1])\n      }\n    }\n  }\n\n  /**\n   * Sets the points making up the polygon. It's important to use this function when changing the polygon's shape to ensure internal data is also updated.\n   * @param {Array<Number[]>} new_points An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n   */\n  setPoints (new_points) {\n    const count = new_points.length\n\n    this._points = new Float64Array(count * 2)\n    this._coords = new Float64Array(count * 2)\n    this._edges = new Float64Array(count * 2)\n    this._normals = new Float64Array(count * 2)\n\n    const points = this._points\n\n    for (let i = 0, ix = 0, iy = 1; i < count; ++i, ix += 2, iy += 2) {\n      const new_point = new_points[i]\n\n      points[ix] = new_point[0]\n      points[iy] = new_point[1]\n    }\n\n    this._dirty_coords = true\n  }\n\n  /**\n   * Calculates and caches the polygon's world coordinates based on its points, angle, and scale\n   */\n  _calculateCoords () {\n    const x = this.x\n    const y = this.y\n    const angle = this.angle\n    const scale_x = this.scale_x\n    const scale_y = this.scale_y\n    const points = this._points\n    const coords = this._coords\n    const count = points.length\n\n    let min_x\n    let max_x\n    let min_y\n    let max_y\n\n    for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n      let coord_x = points[ix] * scale_x\n      let coord_y = points[iy] * scale_y\n\n      if (angle) {\n        const cos = Math.cos(angle)\n        const sin = Math.sin(angle)\n        const tmp_x = coord_x\n        const tmp_y = coord_y\n\n        coord_x = tmp_x * cos - tmp_y * sin\n        coord_y = tmp_x * sin + tmp_y * cos\n      }\n\n      coord_x += x\n      coord_y += y\n\n      coords[ix] = coord_x\n      coords[iy] = coord_y\n\n      if (ix === 0) {\n        min_x = max_x = coord_x\n        min_y = max_y = coord_y\n      } else {\n        if (coord_x < min_x) {\n          min_x = coord_x\n        } else if (coord_x > max_x) {\n          max_x = coord_x\n        }\n\n        if (coord_y < min_y) {\n          min_y = coord_y\n        } else if (coord_y > max_y) {\n          max_y = coord_y\n        }\n      }\n    }\n\n    this._x = x\n    this._y = y\n    this._angle = angle\n    this._scale_x = scale_x\n    this._scale_y = scale_y\n    this._min_x = min_x\n    this._min_y = min_y\n    this._max_x = max_x\n    this._max_y = max_y\n    this._dirty_coords = false\n    this._dirty_normals = true\n  }\n\n  /**\n   * Calculates the normals and edges of the polygon's sides\n   */\n  _calculateNormals () {\n    const coords = this._coords\n    const edges = this._edges\n    const normals = this._normals\n    const count = coords.length\n\n    for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n      const next = ix + 2 < count ? ix + 2 : 0\n      const x = coords[next] - coords[ix]\n      const y = coords[next + 1] - coords[iy]\n      const length = x || y ? Math.sqrt(x * x + y * y) : 0\n\n      edges[ix] = x\n      edges[iy] = y\n      normals[ix] = length ? y / length : 0\n      normals[iy] = length ? -x / length : 0\n    }\n\n    this._dirty_normals = false\n  }\n};\n\nmodule.exports = Polygon\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/Polygon.js?");

/***/ }),

/***/ "./source/modules/Result.js":
/*!**********************************!*\
  !*** ./source/modules/Result.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * An object used to collect the detailed results of a collision test\n *\n * > **Note:** It is highly recommended you recycle the same Result object if possible in order to avoid wasting memory\n * @class\n */\nclass Result {\n  /**\n   * @constructor\n   */\n  constructor () {\n    /**\n     * @desc True if a collision was detected\n     * @type {Boolean}\n     */\n    this.collision = false\n\n    /**\n     * @desc The source body tested\n     * @type {Circle|Polygon|Point}\n     */\n    this.a = null\n\n    /**\n     * @desc The target body tested against\n     * @type {Circle|Polygon|Point}\n     */\n    this.b = null\n\n    /**\n     * @desc True if A is completely contained within B\n     * @type {Boolean}\n     */\n    this.a_in_b = false\n\n    /**\n     * @desc True if B is completely contained within A\n     * @type {Boolean}\n     */\n    this.b_in_a = false\n\n    /**\n     * @desc The magnitude of the shortest axis of overlap\n     * @type {Number}\n     */\n    this.overlap = 0\n\n    /**\n     * @desc The X direction of the shortest axis of overlap\n     * @type {Number}\n     */\n    this.overlap_x = 0\n\n    /**\n     * @desc The Y direction of the shortest axis of overlap\n     * @type {Number}\n     */\n    this.overlap_y = 0\n  }\n};\n\nmodule.exports = Result\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/Result.js?");

/***/ }),

/***/ "./source/modules/SAT.js":
/*!*******************************!*\
  !*** ./source/modules/SAT.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Determines if two bodies are colliding using the Separating Axis Theorem\n * @private\n * @param {Circle|Polygon|Point} a The source body to test\n * @param {Circle|Polygon|Point} b The target body to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own collision heuristic)\n * @returns {Boolean}\n */\nfunction SAT (a, b, result = null, aabb = true) {\n  const a_polygon = a._polygon\n  const b_polygon = b._polygon\n\n  let collision = false\n\n  if (result) {\n    result.a = a\n    result.b = b\n    result.a_in_b = true\n    result.b_in_a = true\n    result.overlap = null\n    result.overlap_x = 0\n    result.overlap_y = 0\n  }\n\n  if (a_polygon) {\n    if (\n      a._dirty_coords ||\n      a.x !== a._x ||\n      a.y !== a._y ||\n      a.angle !== a._angle ||\n      a.scale_x !== a._scale_x ||\n      a.scale_y !== a._scale_y\n    ) {\n      a._calculateCoords()\n    }\n  }\n\n  if (b_polygon) {\n    if (\n      b._dirty_coords ||\n      b.x !== b._x ||\n      b.y !== b._y ||\n      b.angle !== b._angle ||\n      b.scale_x !== b._scale_x ||\n      b.scale_y !== b._scale_y\n    ) {\n      b._calculateCoords()\n    }\n  }\n\n  if (!aabb || aabbAABB(a, b)) {\n    if (a_polygon && a._dirty_normals) {\n      a._calculateNormals()\n    }\n\n    if (b_polygon && b._dirty_normals) {\n      b._calculateNormals()\n    }\n\n    collision = (\n      a_polygon && b_polygon ? polygonPolygon(a, b, result)\n        : a_polygon ? polygonCircle(a, b, result, false)\n          : b_polygon ? polygonCircle(b, a, result, true)\n            : circleCircle(a, b, result)\n    )\n  }\n\n  if (result) {\n    result.collision = collision\n  }\n\n  return collision\n};\n\n/**\n * Determines if two bodies' axis aligned bounding boxes are colliding\n * @param {Circle|Polygon|Point} a The source body to test\n * @param {Circle|Polygon|Point} b The target body to test against\n */\nfunction aabbAABB (a, b) {\n  const a_polygon = a._polygon\n  const a_x = a_polygon ? 0 : a.x\n  const a_y = a_polygon ? 0 : a.y\n  const a_radius = a_polygon ? 0 : a.radius * a.scale\n  const a_min_x = a_polygon ? a._min_x : a_x - a_radius\n  const a_min_y = a_polygon ? a._min_y : a_y - a_radius\n  const a_max_x = a_polygon ? a._max_x : a_x + a_radius\n  const a_max_y = a_polygon ? a._max_y : a_y + a_radius\n\n  const b_polygon = b._polygon\n  const b_x = b_polygon ? 0 : b.x\n  const b_y = b_polygon ? 0 : b.y\n  const b_radius = b_polygon ? 0 : b.radius * b.scale\n  const b_min_x = b_polygon ? b._min_x : b_x - b_radius\n  const b_min_y = b_polygon ? b._min_y : b_y - b_radius\n  const b_max_x = b_polygon ? b._max_x : b_x + b_radius\n  const b_max_y = b_polygon ? b._max_y : b_y + b_radius\n\n  return a_min_x < b_max_x && a_min_y < b_max_y && a_max_x > b_min_x && a_max_y > b_min_y\n}\n\n/**\n * Determines if two polygons are colliding\n * @param {Polygon} a The source polygon to test\n * @param {Polygon} b The target polygon to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction polygonPolygon (a, b, result = null) {\n  const a_count = a._coords.length\n  const b_count = b._coords.length\n\n  // Handle points specially\n  if (a_count === 2 && b_count === 2) {\n    const a_coords = a._coords\n    const b_coords = b._coords\n\n    if (result) {\n      result.overlap = 0\n    }\n\n    return a_coords[0] === b_coords[0] && a_coords[1] === b_coords[1]\n  }\n\n  const a_coords = a._coords\n  const b_coords = b._coords\n  const a_normals = a._normals\n  const b_normals = b._normals\n\n  if (a_count > 2) {\n    for (let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n      if (separatingAxis(a_coords, b_coords, a_normals[ix], a_normals[iy], result)) {\n        return false\n      }\n    }\n  }\n\n  if (b_count > 2) {\n    for (let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n      if (separatingAxis(a_coords, b_coords, b_normals[ix], b_normals[iy], result)) {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n\n/**\n * Determines if a polygon and a circle are colliding\n * @param {Polygon} a The source polygon to test\n * @param {Circle} b The target circle to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [reverse = false] Set to true to reverse a and b in the result parameter when testing circle->polygon instead of polygon->circle\n * @returns {Boolean}\n */\nfunction polygonCircle (a, b, result = null, reverse = false) {\n  const a_coords = a._coords\n  const a_edges = a._edges\n  const a_normals = a._normals\n  const b_x = b.x\n  const b_y = b.y\n  const b_radius = b.radius * b.scale\n  const b_radius2 = b_radius * 2\n  const radius_squared = b_radius * b_radius\n  const count = a_coords.length\n\n  let a_in_b = true\n  let b_in_a = true\n  let overlap = null\n  let overlap_x = 0\n  let overlap_y = 0\n\n  // Handle points specially\n  if (count === 2) {\n    const coord_x = b_x - a_coords[0]\n    const coord_y = b_y - a_coords[1]\n    const length_squared = coord_x * coord_x + coord_y * coord_y\n\n    if (length_squared > radius_squared) {\n      return false\n    }\n\n    if (result) {\n      const length = Math.sqrt(length_squared)\n\n      overlap = b_radius - length\n      overlap_x = coord_x / length\n      overlap_y = coord_y / length\n      b_in_a = false\n    }\n  } else {\n    for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n      const coord_x = b_x - a_coords[ix]\n      const coord_y = b_y - a_coords[iy]\n      const edge_x = a_edges[ix]\n      const edge_y = a_edges[iy]\n      const dot = coord_x * edge_x + coord_y * edge_y\n      const region = dot < 0 ? -1 : dot > edge_x * edge_x + edge_y * edge_y ? 1 : 0\n\n      let tmp_overlapping = false\n      let tmp_overlap = 0\n      let tmp_overlap_x = 0\n      let tmp_overlap_y = 0\n\n      if (result && a_in_b && coord_x * coord_x + coord_y * coord_y > radius_squared) {\n        a_in_b = false\n      }\n\n      if (region) {\n        const left = region === -1\n        const other_x = left ? (ix === 0 ? count - 2 : ix - 2) : (ix === count - 2 ? 0 : ix + 2)\n        const other_y = other_x + 1\n        const coord2_x = b_x - a_coords[other_x]\n        const coord2_y = b_y - a_coords[other_y]\n        const edge2_x = a_edges[other_x]\n        const edge2_y = a_edges[other_y]\n        const dot2 = coord2_x * edge2_x + coord2_y * edge2_y\n        const region2 = dot2 < 0 ? -1 : dot2 > edge2_x * edge2_x + edge2_y * edge2_y ? 1 : 0\n\n        if (region2 === -region) {\n          const target_x = left ? coord_x : coord2_x\n          const target_y = left ? coord_y : coord2_y\n          const length_squared = target_x * target_x + target_y * target_y\n\n          if (length_squared > radius_squared) {\n            return false\n          }\n\n          if (result) {\n            const length = Math.sqrt(length_squared)\n\n            tmp_overlapping = true\n            tmp_overlap = b_radius - length\n            tmp_overlap_x = target_x / length\n            tmp_overlap_y = target_y / length\n            b_in_a = false\n          }\n        }\n      } else {\n        const normal_x = a_normals[ix]\n        const normal_y = a_normals[iy]\n        const length = coord_x * normal_x + coord_y * normal_y\n        const absolute_length = length < 0 ? -length : length\n\n        if (length > 0 && absolute_length > b_radius) {\n          return false\n        }\n\n        if (result) {\n          tmp_overlapping = true\n          tmp_overlap = b_radius - length\n          tmp_overlap_x = normal_x\n          tmp_overlap_y = normal_y\n\n          if (b_in_a && (length >= 0) || (tmp_overlap < b_radius2)) {\n            b_in_a = false\n          }\n        }\n      }\n\n      if (tmp_overlapping && (overlap === null || overlap > tmp_overlap)) {\n        overlap = tmp_overlap\n        overlap_x = tmp_overlap_x\n        overlap_y = tmp_overlap_y\n      }\n    }\n  }\n\n  if (result) {\n    result.a_in_b = reverse ? b_in_a : a_in_b\n    result.b_in_a = reverse ? a_in_b : b_in_a\n    result.overlap = overlap\n    result.overlap_x = reverse ? -overlap_x : overlap_x\n    result.overlap_y = reverse ? -overlap_y : overlap_y\n  }\n\n  return true\n}\n\n/**\n * Determines if two circles are colliding\n * @param {Circle} a The source circle to test\n * @param {Circle} b The target circle to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction circleCircle (a, b, result = null) {\n  const a_radius = a.radius * a.scale\n  const b_radius = b.radius * b.scale\n  const difference_x = b.x - a.x\n  const difference_y = b.y - a.y\n  const radius_sum = a_radius + b_radius\n  const length_squared = difference_x * difference_x + difference_y * difference_y\n\n  if (length_squared > radius_sum * radius_sum) {\n    return false\n  }\n\n  if (result) {\n    const length = Math.sqrt(length_squared)\n\n    result.a_in_b = a_radius <= b_radius && length <= b_radius - a_radius\n    result.b_in_a = b_radius <= a_radius && length <= a_radius - b_radius\n    result.overlap = radius_sum - length\n    result.overlap_x = difference_x / length\n    result.overlap_y = difference_y / length\n  }\n\n  return true\n}\n\n/**\n * Determines if two polygons are separated by an axis\n * @param {Array<Number[]>} a_coords The coordinates of the polygon to test\n * @param {Array<Number[]>} b_coords The coordinates of the polygon to test against\n * @param {Number} x The X direction of the axis\n * @param {Number} y The Y direction of the axis\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction separatingAxis (a_coords, b_coords, x, y, result = null) {\n  const a_count = a_coords.length\n  const b_count = b_coords.length\n\n  if (!a_count || !b_count) {\n    return true\n  }\n\n  let a_start = null\n  let a_end = null\n  let b_start = null\n  let b_end = null\n\n  for (let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n    const dot = a_coords[ix] * x + a_coords[iy] * y\n\n    if (a_start === null || a_start > dot) {\n      a_start = dot\n    }\n\n    if (a_end === null || a_end < dot) {\n      a_end = dot\n    }\n  }\n\n  for (let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n    const dot = b_coords[ix] * x + b_coords[iy] * y\n\n    if (b_start === null || b_start > dot) {\n      b_start = dot\n    }\n\n    if (b_end === null || b_end < dot) {\n      b_end = dot\n    }\n  }\n\n  if (a_start > b_end || a_end < b_start) {\n    return true\n  }\n\n  if (result) {\n    let overlap = 0\n\n    if (a_start < b_start) {\n      result.a_in_b = false\n\n      if (a_end < b_end) {\n        overlap = a_end - b_start\n        result.b_in_a = false\n      } else {\n        const option1 = a_end - b_start\n        const option2 = b_end - a_start\n\n        overlap = option1 < option2 ? option1 : -option2\n      }\n    } else {\n      result.b_in_a = false\n\n      if (a_end > b_end) {\n        overlap = a_start - b_end\n        result.a_in_b = false\n      } else {\n        const option1 = a_end - b_start\n        const option2 = b_end - a_start\n\n        overlap = option1 < option2 ? option1 : -option2\n      }\n    }\n\n    const current_overlap = result.overlap\n    const absolute_overlap = overlap < 0 ? -overlap : overlap\n\n    if (current_overlap === null || current_overlap > absolute_overlap) {\n      const sign = overlap < 0 ? -1 : 1\n\n      result.overlap = absolute_overlap\n      result.overlap_x = x * sign\n      result.overlap_y = y * sign\n    }\n  }\n\n  return false\n}\n\nmodule.exports = SAT\n\nmodule.exports.default = module.exports\n\n\n//# sourceURL=webpack:///./source/modules/SAT.js?");

/***/ }),

/***/ "./source/modules/index.js":
/*!*********************************!*\
  !*** ./source/modules/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const BVH = __webpack_require__(/*! ./BVH.js */ \"./source/modules/BVH.js\");\nconst Circle = __webpack_require__(/*! ./Circle.js */ \"./source/modules/Circle.js\");\nconst Polygon = __webpack_require__(/*! ./Polygon.js */ \"./source/modules/Polygon.js\");\nconst Point = __webpack_require__(/*! ./Point.js */ \"./source/modules/Point.js\");\nconst Result = __webpack_require__(/*! ./Result.js */ \"./source/modules/Result.js\");\nconst SAT = __webpack_require__(/*! ./SAT.js */ \"./source/modules/SAT.js\");\n\nmodule.exports = {\n  BVH,\n  Circle,\n  Polygon,\n  Point,\n  Result,\n  SAT\n};\n\n\n//# sourceURL=webpack:///./source/modules/index.js?");

/***/ })

/******/ });